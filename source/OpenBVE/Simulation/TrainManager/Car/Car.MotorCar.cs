namespace OpenBve
{
	public static partial class TrainManager
	{
		internal class MotorCar : Car
		{
			internal double DecelerationDueToMotor;

			internal MotorCar(Train train, int index) : base(train, index)
			{
			}

			internal override void UpdateAcceleration(double TimeElapsed)
			{
				// power
				WheelSpin = 0.0;
				double wheelSlipAccelerationMotorFront;
				double wheelSlipAccelerationMotorRear;
				if (Derailed)
				{
					wheelSlipAccelerationMotorFront = 0.0;
					wheelSlipAccelerationMotorRear = 0.0;
				}
				else
				{
					wheelSlipAccelerationMotorFront = GetCriticalWheelSlipAccelerationForElectricMotor(FrontAxle, CurrentSpeed);
					wheelSlipAccelerationMotorRear = GetCriticalWheelSlipAccelerationForElectricMotor(RearAxle, CurrentSpeed);

				}

				if (DecelerationDueToMotor == 0.0)
				{
					double a;
					if (DecelerationDueToMotor == 0.0)
					{
						if (baseTrain.Handles.Reverser.Actual != 0 & baseTrain.Handles.Power.Actual > 0 & !baseTrain.Handles.HoldBrake.Actual & !baseTrain.Handles.EmergencyBrake.Actual)
						{
							// target acceleration
							if (baseTrain.Handles.Power.Actual - 1 < AccelerationCurves.Length)
							{
								// Load factor is a constant 1.0 for anything prior to BVE5
								// This will need to be changed when the relevant branch is merged in
								a = AccelerationCurves[baseTrain.Handles.Power.Actual - 1].GetAccelerationOutput((double) baseTrain.Handles.Reverser.Actual * CurrentSpeed, 1.0);
							}
							else
							{
								a = 0.0;
							}

							// readhesion device
							if (a > Specs.ReAdhesionDevice.MaximumAccelerationOutput)
							{
								a = Specs.ReAdhesionDevice.MaximumAccelerationOutput;
							}

							// wheel slip
							if (a < wheelSlipAccelerationMotorFront)
							{
								FrontAxle.CurrentWheelSlip = false;
							}
							else
							{
								FrontAxle.CurrentWheelSlip = true;
								WheelSpin += (double) baseTrain.Handles.Reverser.Actual * a * Specs.MassCurrent;
							}

							if (a < wheelSlipAccelerationMotorRear)
							{
								RearAxle.CurrentWheelSlip = false;
							}
							else
							{
								RearAxle.CurrentWheelSlip = true;
								WheelSpin += (double) baseTrain.Handles.Reverser.Actual * a * Specs.MassCurrent;
							}

							// Update readhesion device
							Specs.ReAdhesionDevice.Update(a);
							// Update constant speed device

							Specs.ConstSpeed.Update(ref a, baseTrain.Specs.CurrentConstSpeed, baseTrain.Handles.Reverser.Actual);

							// finalize
							if (WheelSpin != 0.0) a = 0.0;
						}
						else
						{
							a = 0.0;
							FrontAxle.CurrentWheelSlip = false;
							RearAxle.CurrentWheelSlip = false;
						}
					}
					else
					{
						a = 0.0;
						FrontAxle.CurrentWheelSlip = false;
						RearAxle.CurrentWheelSlip = false;
					}

					if (!Derailed)
					{
						if (Specs.CurrentAccelerationOutput < a)
						{
							if (Specs.CurrentAccelerationOutput < 0.0)
							{
								Specs.CurrentAccelerationOutput += Specs.JerkBrakeDown * TimeElapsed;
							}
							else
							{
								Specs.CurrentAccelerationOutput += Specs.JerkPowerUp * TimeElapsed;
							}

							if (Specs.CurrentAccelerationOutput > a)
							{
								Specs.CurrentAccelerationOutput = a;
							}
						}
						else
						{
							Specs.CurrentAccelerationOutput -= Specs.JerkPowerDown * TimeElapsed;
							if (Specs.CurrentAccelerationOutput < a)
							{
								Specs.CurrentAccelerationOutput = a;
							}
						}
					}
					else
					{
						Specs.CurrentAccelerationOutput = 0.0;
					}
				}
			}


			/// <summary>Holds the acceleration curves generated by the motor</summary>
			internal AccelerationCurve[] AccelerationCurves;
		}
	}
}
