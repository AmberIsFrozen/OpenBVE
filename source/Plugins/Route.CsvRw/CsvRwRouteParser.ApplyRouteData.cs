using System;
using System.Collections.Generic;
using System.Linq;
using OpenBveApi.Colors;
using OpenBveApi.Math;
using OpenBveApi.Runtime;
using OpenBveApi.World;
using OpenBveApi.Interface;
using OpenBveApi.Objects;
using OpenBveApi.Textures;
using OpenBveApi.Routes;
using OpenBveApi.Sounds;
using RouteManager2.Climate;
using RouteManager2.Events;
using RouteManager2.SignalManager;

namespace CsvRwRouteParser
{
	internal partial class Parser
	{
		private void ApplyRouteData(string FileName, ref RouteData Data, bool PreviewOnly)
		{
			if (CompatibilityObjectsUsed != 0)
			{
				Plugin.CurrentHost.AddMessage(MessageType.Warning, false, "Warning: " + CompatibilityObjectsUsed + " compatibility objects were used.");
			}
			if (PreviewOnly)
			{
				if (freeObjCount == 0 && railtypeCount == 0)
				{
					throw new Exception(Translations.GetInterfaceString("errors_route_corrupt_noobjects"));
				}
			}
			string LimitGraphicsPath = null;
			
			if (!PreviewOnly)
			{
				CompatibilityObjects.LoadAutoGeneratedObjects(CompatibilityFolder, out LimitGraphicsPath);
			}
			
			// initialize
			int LastBlock = (int)Math.Floor((Data.TrackPosition + 600.0) / Data.BlockInterval + 0.001) + 1;
			if (Data.Blocks[Data.Blocks.Length - 1].CurrentTrackState.CurveRadius < 300)
			{
				/*
				 * The track end event is placed 600m after the end of the final block
				 * If our curve radius in the final block is < 300, then our train will
				 * re-appear erroneously if the player is watching the final block
				 */
				Data.Blocks[Data.Blocks.Length - 1].CurrentTrackState.CurveRadius = 0.0;
			}
			int BlocksUsed = Data.Blocks.Length;
			Data.CreateMissingBlocks(ref BlocksUsed, LastBlock, PreviewOnly);
			Array.Resize(ref Data.Blocks, BlocksUsed);
			// interpolate height
			if (!PreviewOnly)
			{
				int z = 0;
				for (int i = 0; i < Data.Blocks.Length; i++)
				{
					if (!double.IsNaN(Data.Blocks[i].Height))
					{
						for (int j = i - 1; j >= 0; j--)
						{
							if (!double.IsNaN(Data.Blocks[j].Height))
							{
								double a = Data.Blocks[j].Height;
								double b = Data.Blocks[i].Height;
								double d = (b - a) / (i - j);
								for (int k = j + 1; k < i; k++)
								{
									a += d;
									Data.Blocks[k].Height = a;
								}
								break;
							}
						}
						z = i;
					}
				}
				for (int i = z + 1; i < Data.Blocks.Length; i++)
				{
					Data.Blocks[i].Height = Data.Blocks[z].Height;
				}
			}
			// background
			if (!PreviewOnly)
			{
				if (Data.Blocks[0].Background >= 0 & Data.Backgrounds.ContainsKey(Data.Blocks[0].Background))
				{
					CurrentRoute.CurrentBackground = Data.Backgrounds[Data.Blocks[0].Background];
				}
				else
				{
					if (Plugin.CurrentOptions.EnableBveTsHacks && Data.Backgrounds.Count == 0)
					{
						/*
						 * If no backgrounds are defined, this causes some interesting render artifacts
						 */
						Plugin.CurrentHost.AddMessage(MessageType.Warning, false, "No backgrounds were defined- Using default background.");
						string f = OpenBveApi.Path.CombineFile(Plugin.FileSystem.GetDataFolder("Compatibility"), "Uchibo\\Back_Mt.png");
						Texture t;
						Plugin.CurrentHost.RegisterTexture(f, new TextureParameters(null, null), out t);
						CurrentRoute.CurrentBackground = new StaticBackground(t, 6, false, Plugin.CurrentOptions.ViewingDistance);
					}
					else if (Data.Backgrounds.Count > 0 && !Data.Backgrounds.ContainsKey(0) && Data.Blocks[0].Background == 0)
					{
						/*
						 * Nasty little variant on the above-
						 * Zero background is not defined, and the route doesn't start at zero
						 *
						 * Don't hide behind the hacks option, as routes can start at a non-zero position with a
						 * non-zero background quite validly
						 */
						CurrentRoute.CurrentBackground = Data.Backgrounds[Data.Backgrounds.ElementAt(0).Key];
					}
					else
					{
						CurrentRoute.CurrentBackground = new StaticBackground(null, 6, false, Plugin.CurrentOptions.ViewingDistance);
					}
				}
				CurrentRoute.TargetBackground = CurrentRoute.CurrentBackground;
			}
			// brightness
			int CurrentBrightnessElement = -1;
			int CurrentBrightnessEvent = -1;
			float CurrentBrightnessValue = 1.0f;
			double CurrentBrightnessTrackPosition = Data.FirstUsedBlock * Data.BlockInterval;
			if (!PreviewOnly)
			{
				for (int i = Data.FirstUsedBlock; i < Data.Blocks.Length; i++)
				{
					if (Data.Blocks[i].BrightnessChanges != null && Data.Blocks[i].BrightnessChanges.Length != 0)
					{
						CurrentBrightnessValue = Data.Blocks[i].BrightnessChanges[0].Value;
						CurrentBrightnessTrackPosition = Data.Blocks[i].BrightnessChanges[0].Value;
						break;
					}
				}
			}
			// create objects and track
			Vector3 Position = Vector3.Zero;
			Vector2 Direction = new Vector2(0.0, 1.0);
			double CurrentSpeedLimit = double.PositiveInfinity;
			int CurrentRunIndex = 0;
			int CurrentFlangeIndex = 0;
			if (Data.FirstUsedBlock < 0) Data.FirstUsedBlock = 0;
			int CurrentTrackLength = 0;
			int PreviousFogElement = -1;
			int PreviousFogEvent = -1;
			Fog PreviousFog = new Fog(CurrentRoute.NoFogStart, CurrentRoute.NoFogEnd, Color24.Grey, -Data.BlockInterval);
			Fog CurrentFog = new Fog(CurrentRoute.NoFogStart, CurrentRoute.NoFogEnd, Color24.Grey, 0.0);
			for (int i = Data.FirstUsedBlock; i < Data.Blocks.Length; i++)
			{
				if (Data.Blocks[i].Rails.Count > CurrentRoute.Tracks.Count)
				{
					for (int d = 0; d < Data.Blocks[i].Rails.Count; d++)
					{
						var item = Data.Blocks[i].Rails.ElementAt(d);
						if (!CurrentRoute.Tracks.ContainsKey(item.Key))
						{
							CurrentRoute.Tracks.Add(item.Key, new Track());
							CurrentRoute.Tracks[item.Key].Elements = new TrackElement[256];
						}
					}
				}
			}
			// process blocks
			double progressFactor = Data.Blocks.Length - Data.FirstUsedBlock == 0 ? 0.5 : 0.5 / (Data.Blocks.Length - Data.FirstUsedBlock);
			for (int i = Data.FirstUsedBlock; i < Data.Blocks.Length; i++)
			{
				Plugin.CurrentProgress = 0.6667 + (i - Data.FirstUsedBlock) * progressFactor;
				if ((i & 15) == 0)
				{
					System.Threading.Thread.Sleep(1);
					if (Plugin.Cancel) return;
				}
				double StartingDistance = i * Data.BlockInterval;
				double EndingDistance = StartingDistance + Data.BlockInterval;
				// normalize
				Direction.Normalize();
				// track
				if (!PreviewOnly)
				{
					if (Data.Blocks[i].Cycle.Length == 1 && Data.Blocks[i].Cycle[0] == -1)
					{
						if (Data.Structure.Cycles.Length == 0 || Data.Structure.Cycles[0] == null)
						{
							Data.Blocks[i].Cycle = new[] { 0 };
						}
						else
						{
							Data.Blocks[i].Cycle = Data.Structure.Cycles[0];
						}
					}
				}
				TrackElement WorldTrackElement = Data.Blocks[i].CurrentTrackState;
				int n = CurrentTrackLength;
				for (int j = 0; j < CurrentRoute.Tracks.Count; j++)
				{
					if (PreviewOnly && j != 0)
					{
						break;
					}
					var key = CurrentRoute.Tracks.ElementAt(j).Key;
					if (CurrentRoute.Tracks[key].Elements == null || CurrentRoute.Tracks[key].Elements.Length == 0)
					{
						CurrentRoute.Tracks[key].Elements = new TrackElement[256];
					}
					if (n >= CurrentRoute.Tracks[key].Elements.Length)
					{
						Array.Resize(ref CurrentRoute.Tracks[key].Elements, CurrentRoute.Tracks[key].Elements.Length << 1);
					}
				}
				CurrentTrackLength++;
				CurrentRoute.Tracks[0].Elements[n] = WorldTrackElement;
				CurrentRoute.Tracks[0].Elements[n].WorldPosition = Position;
				CurrentRoute.Tracks[0].Elements[n].WorldDirection = Vector3.GetVector3(Direction, Data.Blocks[i].Pitch);
				CurrentRoute.Tracks[0].Elements[n].WorldSide = new Vector3(Direction.Y, 0.0, -Direction.X);
				CurrentRoute.Tracks[0].Elements[n].WorldUp = Vector3.Cross(CurrentRoute.Tracks[0].Elements[n].WorldDirection, CurrentRoute.Tracks[0].Elements[n].WorldSide);
				CurrentRoute.Tracks[0].Elements[n].StartingTrackPosition = StartingDistance;
				CurrentRoute.Tracks[0].Elements[n].AdhesionMultiplier = Data.Blocks[i].AdhesionMultiplier;
				CurrentRoute.Tracks[0].Elements[n].CsvRwAccuracyLevel = Data.Blocks[i].Accuracy;
				for (int j = 0; j < CurrentRoute.Tracks.Count; j++)
				{
					if (PreviewOnly && j != 0)
					{
						break;
					}
					var key = CurrentRoute.Tracks.ElementAt(j).Key;
					CurrentRoute.Tracks[key].Elements[n].Events = new GeneralEvent[] { };
				}
				// background
				if (!PreviewOnly)
				{
					if (Data.Blocks[i].Background >= 0)
					{
						int typ;
						if (i == Data.FirstUsedBlock)
						{
							typ = Data.Blocks[i].Background;
						}
						else
						{
							typ = Data.Backgrounds.Count > 0 ? 0 : -1;
							for (int j = i - 1; j >= Data.FirstUsedBlock; j--)
							{
								if (Data.Blocks[j].Background >= 0)
								{
									typ = Data.Blocks[j].Background;
									break;
								}
							}
						}
						if (typ >= 0 & Data.Backgrounds.ContainsKey(typ))
						{
							int m = CurrentRoute.Tracks[0].Elements[n].Events.Length;
							Array.Resize(ref CurrentRoute.Tracks[0].Elements[n].Events, m + 1);
							CurrentRoute.Tracks[0].Elements[n].Events[m] = new BackgroundChangeEvent(CurrentRoute, 0.0, Data.Backgrounds[typ], Data.Backgrounds[Data.Blocks[i].Background]);
						}
					}
				}
				// brightness
				if (!PreviewOnly)
				{
					for (int j = 0; j < Data.Blocks[i].BrightnessChanges.Length; j++)
					{
						/*
						 * Legacy brightness: This applies equally to all tracks in a block
						 */
						for (int tt = 0; tt < CurrentRoute.Tracks.Count; tt++)
						{
							int t = CurrentRoute.Tracks.ElementAt(tt).Key;
							int m = CurrentRoute.Tracks[t].Elements[n].Events.Length;
							Array.Resize(ref CurrentRoute.Tracks[t].Elements[n].Events, m + 1);
							double d = Data.Blocks[i].BrightnessChanges[j].TrackPosition - StartingDistance;
							CurrentRoute.Tracks[t].Elements[n].Events[m] = new BrightnessChangeEvent(d, Data.Blocks[i].BrightnessChanges[j].Value, CurrentBrightnessValue, Data.Blocks[i].BrightnessChanges[j].TrackPosition - CurrentBrightnessTrackPosition);
							
							if (t == 0)
							{
								if (CurrentBrightnessElement >= 0 & CurrentBrightnessEvent >= 0)
								{
									BrightnessChangeEvent bce = (BrightnessChangeEvent)CurrentRoute.Tracks[t].Elements[CurrentBrightnessElement].Events[CurrentBrightnessEvent];
									bce.NextBrightness = Data.Blocks[i].BrightnessChanges[j].Value;
									bce.NextDistance = Data.Blocks[i].BrightnessChanges[j].TrackPosition - CurrentBrightnessTrackPosition;
								}
								CurrentBrightnessEvent = m;
								
							}
							else
							{
								if (CurrentBrightnessElement >= 0 & CurrentBrightnessEvent >= 0)
								{
									for (int e = 0; e < CurrentRoute.Tracks[t].Elements[CurrentBrightnessElement].Events.Length; e++)
									{
										if (!(CurrentRoute.Tracks[t].Elements[CurrentBrightnessElement].Events[e] is BrightnessChangeEvent))
											continue;
										BrightnessChangeEvent bce = (BrightnessChangeEvent)CurrentRoute.Tracks[t].Elements[CurrentBrightnessElement].Events[e];
										bce.NextBrightness = Data.Blocks[i].BrightnessChanges[j].Value;
										bce.NextDistance = Data.Blocks[i].BrightnessChanges[j].TrackPosition - CurrentBrightnessTrackPosition;
									}
								}
							}
						}
						CurrentBrightnessElement = n;
						CurrentBrightnessTrackPosition = Data.Blocks[i].BrightnessChanges[j].TrackPosition;
						CurrentBrightnessValue = Data.Blocks[i].BrightnessChanges[j].Value;
					}
				}
				// fog
				if (!PreviewOnly)
				{
					if (Data.FogTransitionMode)
					{
						if (Data.Blocks[i].FogDefined)
						{
							if (i == 0 && StartingDistance == 0)
							{
								//Fog starts at zero position
								PreviousFog = Data.Blocks[i].Fog;
							}
							Data.Blocks[i].Fog.TrackPosition = StartingDistance;
							int m = CurrentRoute.Tracks[0].Elements[n].Events.Length;
							Array.Resize(ref CurrentRoute.Tracks[0].Elements[n].Events, m + 1);
							CurrentRoute.Tracks[0].Elements[n].Events[m] = new FogChangeEvent(CurrentRoute, 0.0, PreviousFog, Data.Blocks[i].Fog, Data.Blocks[i].Fog);
							if (PreviousFogElement >= 0 & PreviousFogEvent >= 0)
							{
								FogChangeEvent e = (FogChangeEvent)CurrentRoute.Tracks[0].Elements[PreviousFogElement].Events[PreviousFogEvent];
								e.NextFog = Data.Blocks[i].Fog;
							}
							else
							{
								CurrentRoute.PreviousFog = PreviousFog;
								CurrentRoute.CurrentFog = PreviousFog;
								CurrentRoute.NextFog = Data.Blocks[i].Fog;
							}
							PreviousFog = Data.Blocks[i].Fog;
							PreviousFogElement = n;
							PreviousFogEvent = m;
						}
					}
					else
					{
						if (i == 0 && StartingDistance == 0)
						{
							//Fog starts at zero position
							CurrentFog = Data.Blocks[i].Fog;
							PreviousFog = CurrentFog;
							CurrentRoute.PreviousFog = CurrentFog;
							CurrentRoute.CurrentFog = CurrentFog;
							CurrentRoute.NextFog = CurrentFog;


						}
						else
						{
							Data.Blocks[i].Fog.TrackPosition = StartingDistance + Data.BlockInterval;
							int m = CurrentRoute.Tracks[0].Elements[n].Events.Length;
							Array.Resize(ref CurrentRoute.Tracks[0].Elements[n].Events, m + 1);
							CurrentRoute.Tracks[0].Elements[n].Events[m] = new FogChangeEvent(CurrentRoute, 0.0, PreviousFog, CurrentFog, Data.Blocks[i].Fog);
							PreviousFog = CurrentFog;
							CurrentFog = Data.Blocks[i].Fog;
						}
					}
				}
				// rail sounds
				if (!PreviewOnly)
				{
					int j = Data.Blocks[i].RailType[0];
					int r = j < Data.Structure.Run.Length ? Data.Structure.Run[j] : 0;
					int f = j < Data.Structure.Flange.Length ? Data.Structure.Flange[j] : 0;
					if (CurrentRunIndex != r || CurrentFlangeIndex != f)
					{
						int m = CurrentRoute.Tracks[0].Elements[n].Events.Length;
						Array.Resize(ref CurrentRoute.Tracks[0].Elements[n].Events, m + 1);
						CurrentRoute.Tracks[0].Elements[n].Events[m] = new RailSoundsChangeEvent(0.0, CurrentRunIndex, CurrentFlangeIndex, r, f);
					}
					
					CurrentRunIndex = r;
					CurrentFlangeIndex = f;
				}
				// point sound
				if (!PreviewOnly)
				{
					if (i < Data.Blocks.Length - 1)
					{
						for (int jj = 0; jj < Data.Blocks[i].Rails.Count; jj++)
						{
							int j = Data.Blocks[i].Rails.ElementAt(jj).Key;
							if (Data.Blocks[i].Rails[j].RailStarted & Data.Blocks[i + 1].Rails.ContainsKey(j))
							{
								bool q = false;
								for (int kk = 0; kk < Data.Blocks[i].Rails.Count; kk++)
								{
									int k = Data.Blocks[i].Rails.ElementAt(kk).Key;
									if (Data.Blocks[i].Rails[k].RailStarted & Data.Blocks[i + 1].Rails.ContainsKey(k))
									{
										bool qx = Math.Sign(Data.Blocks[i].Rails[k].RailStart.X - Data.Blocks[i].Rails[j].RailStart.X) != Math.Sign(Data.Blocks[i + 1].Rails[k].RailEnd.X - Data.Blocks[i + 1].Rails[j].RailEnd.X);
										bool qy = (Data.Blocks[i].Rails[k].RailStart.Y - Data.Blocks[i].Rails[j].RailStart.Y) * (Data.Blocks[i + 1].Rails[k].RailEnd.Y - Data.Blocks[i + 1].Rails[j].RailEnd.Y) <= 0.0;
										if (qx & qy)
										{
											q = true;
											break;
										}
									}
								}
								if (q)
								{
									int m = CurrentRoute.Tracks[j].Elements[n].Events.Length;
									Array.Resize(ref CurrentRoute.Tracks[j].Elements[n].Events, m + 1);
									CurrentRoute.Tracks[j].Elements[n].Events[m] = new PointSoundEvent();
								}
							}
						}
					}
				}
				// station
				if (Data.Blocks[i].Station >= 0)
				{
					// station
					int s = Data.Blocks[i].Station;
					int m = CurrentRoute.Tracks[0].Elements[n].Events.Length;
					Array.Resize(ref CurrentRoute.Tracks[0].Elements[n].Events, m + 1);
					CurrentRoute.Tracks[0].Elements[n].Events[m] = new StationStartEvent(0.0, s);
					double dx, dy = 3.0;
					if (CurrentRoute.Stations[s].OpenLeftDoors & !CurrentRoute.Stations[s].OpenRightDoors)
					{
						dx = -5.0;
					}
					else if (!CurrentRoute.Stations[s].OpenLeftDoors & CurrentRoute.Stations[s].OpenRightDoors)
					{
						dx = 5.0;
					}
					else
					{
						dx = 0.0;
					}
					CurrentRoute.Stations[s].SoundOrigin = Position + dx * CurrentRoute.Tracks[0].Elements[n].WorldSide + dy * CurrentRoute.Tracks[0].Elements[n].WorldUp;
					// passalarm
					if (!PreviewOnly)
					{
						if (Data.Blocks[i].StationPassAlarm)
						{
							int b = Data.BlockInterval != 25.0 ? i - (int) (150.0 / Data.BlockInterval) : i - 6;
							if (b >= 0)
							{
								int j = b - Data.FirstUsedBlock;
								if (j >= 0)
								{
									m = CurrentRoute.Tracks[0].Elements[j].Events.Length;
									Array.Resize(ref CurrentRoute.Tracks[0].Elements[j].Events, m + 1);
									CurrentRoute.Tracks[0].Elements[j].Events[m] = new StationPassAlarmEvent(0.0);
								}
							}
						}
					}
				}
				// stop
				for (int j = 0; j < Data.Blocks[i].StopPositions.Length; j++)
				{
					Data.Blocks[i].StopPositions[j].CreateEvent(ref CurrentRoute.Stations, Position, CurrentRoute.Tracks[0].Elements[n].WorldUp, CurrentRoute.Tracks[0].Elements[n].WorldSide);
				}
				// limit
				if (!PreviewOnly)
				{
					for (int j = 0; j < Data.Blocks[i].Limits.Length; j++)
					{
						int m = CurrentRoute.Tracks[0].Elements[n].Events.Length;
						Array.Resize(ref CurrentRoute.Tracks[0].Elements[n].Events, m + 1);
						double d = Data.Blocks[i].Limits[j].TrackPosition - StartingDistance;
						CurrentRoute.Tracks[0].Elements[n].Events[m] = new LimitChangeEvent(d, CurrentSpeedLimit, Data.Blocks[i].Limits[j].Speed);
						CurrentSpeedLimit = Data.Blocks[i].Limits[j].Speed;
					}
				}
				// marker
				if (!PreviewOnly)
				{
					for (int j = 0; j < Data.Markers.Length; j++)
					{
						if (Data.Markers[j].StartingPosition >= StartingDistance & Data.Markers[j].StartingPosition < EndingDistance)
						{
							int m = CurrentRoute.Tracks[0].Elements[n].Events.Length;
							Array.Resize(ref CurrentRoute.Tracks[0].Elements[n].Events, m + 1);
							double d = Data.Markers[j].StartingPosition - StartingDistance;
							if (Data.Markers[j].Message != null)
							{
								CurrentRoute.Tracks[0].Elements[n].Events[m] = new MarkerStartEvent(d, Data.Markers[j].Message, Plugin.CurrentHost);
							}
						}
						if (Data.Markers[j].EndingPosition >= StartingDistance & Data.Markers[j].EndingPosition < EndingDistance)
						{
							int m = CurrentRoute.Tracks[0].Elements[n].Events.Length;
							Array.Resize(ref CurrentRoute.Tracks[0].Elements[n].Events, m + 1);
							double d = Data.Markers[j].EndingPosition - StartingDistance;
							if (Data.Markers[j].Message != null)
							{
								CurrentRoute.Tracks[0].Elements[n].Events[m] = new MarkerEndEvent(d, Data.Markers[j].Message, Plugin.CurrentHost);
							}
						}
					}
				}
				// request stops
				if (!PreviewOnly)
				{
					for (int j = 0; j < Data.RequestStops.Length; j++)
					{
						if (Data.RequestStops[j].TrackPosition >= StartingDistance & Data.RequestStops[j].TrackPosition < EndingDistance)
						{
							int m = CurrentRoute.Tracks[0].Elements[n].Events.Length;
							Array.Resize(ref CurrentRoute.Tracks[0].Elements[n].Events, m + 1);
							CurrentRoute.Tracks[0].Elements[n].Events[m] = new RequestStopEvent(CurrentRoute, Data.RequestStops[j].StationIndex, Data.RequestStops[j].MaxNumberOfCars, Data.RequestStops[j].FullSpeed, Data.RequestStops[j].OnTime, Data.RequestStops[j].Early, Data.RequestStops[j].Late);
						}
						
					}
				}
				// sound
				if (!PreviewOnly)
				{
					for (int j = 0; j < Data.Blocks[i].SoundEvents.Length; j++)
					{
						if (Data.Blocks[i].SoundEvents[j].Type == SoundType.TrainStatic | Data.Blocks[i].SoundEvents[j].Type == SoundType.TrainDynamic)
						{
							int m = CurrentRoute.Tracks[0].Elements[n].Events.Length;
							Array.Resize(ref CurrentRoute.Tracks[0].Elements[n].Events, m + 1);
							double d = Data.Blocks[i].SoundEvents[j].TrackPosition - StartingDistance;
							switch (Data.Blocks[i].SoundEvents[j].Type)
							{
								case SoundType.TrainStatic:
									CurrentRoute.Tracks[0].Elements[n].Events[m] = new SoundEvent(d, Data.Blocks[i].SoundEvents[j].SoundBuffer, true, true, false, Vector3.Zero, 0.0, Plugin.CurrentHost);
									break;
								case SoundType.TrainDynamic:
									CurrentRoute.Tracks[0].Elements[n].Events[m] = new SoundEvent(d, Data.Blocks[i].SoundEvents[j].SoundBuffer, false, false, true, Vector3.Zero, Data.Blocks[i].SoundEvents[j].Speed, Plugin.CurrentHost);
									break;
							}
						}
					}
				}
				// turn
				if (Data.Blocks[i].Turn != 0.0)
				{
					double ag = -Math.Atan(Data.Blocks[i].Turn);
					double cosag = Math.Cos(ag);
					double sinag = Math.Sin(ag);
					Direction.Rotate(cosag, sinag);
					CurrentRoute.Tracks[0].Elements[n].WorldDirection.RotatePlane(cosag, sinag);
					CurrentRoute.Tracks[0].Elements[n].WorldSide.RotatePlane(cosag, sinag);
					CurrentRoute.Tracks[0].Elements[n].WorldUp = Vector3.Cross(CurrentRoute.Tracks[0].Elements[n].WorldDirection, CurrentRoute.Tracks[0].Elements[n].WorldSide);
				}
				//Pitch
				CurrentRoute.Tracks[0].Elements[n].Pitch = Data.Blocks[i].Pitch;
				// curves
				double a = 0.0;
				double c = Data.BlockInterval;
				double h = 0.0;
				if (WorldTrackElement.CurveRadius != 0.0 & Data.Blocks[i].Pitch != 0.0)
				{
					double d = Data.BlockInterval;
					double p = Data.Blocks[i].Pitch;
					double r = WorldTrackElement.CurveRadius;
					double s = d / Math.Sqrt(1.0 + p * p);
					h = s * p;
					double b = s / Math.Abs(r);
					c = Math.Sqrt(2.0 * r * r * (1.0 - Math.Cos(b)));
					a = 0.5 * Math.Sign(r) * b;
					Direction.Rotate(Math.Cos(-a), Math.Sin(-a));
				}
				else if (WorldTrackElement.CurveRadius != 0.0)
				{
					double d = Data.BlockInterval;
					double r = WorldTrackElement.CurveRadius;
					double b = d / Math.Abs(r);
					c = Math.Sqrt(2.0 * r * r * (1.0 - Math.Cos(b)));
					a = 0.5 * Math.Sign(r) * b;
					Direction.Rotate(Math.Cos(-a), Math.Sin(-a));
				}
				else if (Data.Blocks[i].Pitch != 0.0)
				{
					double p = Data.Blocks[i].Pitch;
					double d = Data.BlockInterval;
					c = d / Math.Sqrt(1.0 + p * p);
					h = c * p;
				}

				Transformation TrackTransformation = null;
				Transformation GroundTransformation = null;
				if (!PreviewOnly)
				{
					double TrackYaw = Math.Atan2(Direction.X, Direction.Y);
					double TrackPitch = Math.Atan(Data.Blocks[i].Pitch);
					GroundTransformation = new Transformation(TrackYaw, 0.0, 0.0);
					TrackTransformation = new Transformation(TrackYaw, TrackPitch, 0.0);
				}
				
				// ground
				if (!PreviewOnly)
				{
					int cb = (int)Math.Floor(i + 0.001);
					int ci = (cb % Data.Blocks[i].Cycle.Length + Data.Blocks[i].Cycle.Length) % Data.Blocks[i].Cycle.Length;
					int gi = Data.Blocks[i].Cycle[ci];
					if (gi >= 0 & Data.Structure.Ground.ContainsKey(gi))
					{
						Data.Structure.Ground[Data.Blocks[i].Cycle[ci]].CreateObject(Position + new Vector3(0.0, -Data.Blocks[i].Height, 0.0), GroundTransformation, Transformation.NullTransformation, Data.AccurateObjectDisposal, StartingDistance, EndingDistance, Data.BlockInterval, StartingDistance);
					}
				}
				// ground-aligned free objects
				if (!PreviewOnly)
				{
					for (int j = 0; j < Data.Blocks[i].GroundFreeObj.Length; j++)
					{
						Data.Blocks[i].GroundFreeObj[j].CreateGroundAligned(Data.Structure.FreeObjects, Position, GroundTransformation, Direction, Data.Blocks[i].Height, StartingDistance, EndingDistance, Data.BlockInterval, Data.AccurateObjectDisposal);
					}
				}
				// rail-aligned objects
				if (!PreviewOnly)
				{
					for (int jj = 0; jj < Data.Blocks[i].Rails.Count; jj++)
					{
						int j = Data.Blocks[i].Rails.ElementAt(jj).Key;
						if (j > 0 && !Data.Blocks[i].Rails[j].RailStarted)
						{
							Plugin.CurrentRoute.Tracks[j].Elements[n].InvalidElement = true;
							continue;
						}
						// rail
						Vector3 pos;
						Transformation RailTransformation = new Transformation();
						double planar, updown;
						if (j == 0)
						{
							// rail 0
							planar = 0.0;
							updown = 0.0;
							RailTransformation = new Transformation(TrackTransformation, planar, updown, 0.0);
							pos = Position;
						}
						else
						{
							// rails 1-infinity
							double x = Data.Blocks[i].Rails[j].RailStart.X;
							double y = Data.Blocks[i].Rails[j].RailStart.Y;
							Vector3 offset = new Vector3(Direction.Y * x, y, -Direction.X * x);
							pos = Position + offset;
							if (i < Data.Blocks.Length - 1 && Data.Blocks[i + 1].Rails.ContainsKey(j))
							{
								// take orientation of upcoming block into account
								Vector2 Direction2 = Direction;
								Vector3 Position2 = Position;
								Position2.X += Direction.X * c;
								Position2.Y += h;
								Position2.Z += Direction.Y * c;
								if (a != 0.0)
								{
									Direction2.Rotate(Math.Cos(-a), Math.Sin(-a));
								}
								if (Data.Blocks[i + 1].Turn != 0.0)
								{
									double ag = -Math.Atan(Data.Blocks[i + 1].Turn);
									double cosag = Math.Cos(ag);
									double sinag = Math.Sin(ag);
									Direction2.Rotate(cosag, sinag);
								}
								double a2;
								// double c2 = Data.BlockInterval;
								// double h2 = 0.0;
								if (Data.Blocks[i + 1].CurrentTrackState.CurveRadius != 0.0 & Data.Blocks[i + 1].Pitch != 0.0)
								{
									double d2 = Data.BlockInterval;
									double p2 = Data.Blocks[i + 1].Pitch;
									double r2 = Data.Blocks[i + 1].CurrentTrackState.CurveRadius;
									double s2 = d2 / Math.Sqrt(1.0 + p2 * p2);
									// h2 = s2 * p2;
									double b2 = s2 / Math.Abs(r2);
									// c2 = Math.Sqrt(2.0 * r2 * r2 * (1.0 - Math.Cos(b2)));
									a2 = 0.5 * Math.Sign(r2) * b2;
									Direction2.Rotate(Math.Cos(-a2), Math.Sin(-a2));
								}
								else if (Data.Blocks[i + 1].CurrentTrackState.CurveRadius != 0.0)
								{
									double d2 = Data.BlockInterval;
									double r2 = Data.Blocks[i + 1].CurrentTrackState.CurveRadius;
									double b2 = d2 / Math.Abs(r2);
									// c2 = Math.Sqrt(2.0 * r2 * r2 * (1.0 - Math.Cos(b2)));
									a2 = 0.5 * Math.Sign(r2) * b2;
									Direction2.Rotate(Math.Cos(-a2), Math.Sin(-a2));
								}
								// else if (Data.Blocks[i + 1].Pitch != 0.0) {
								// double p2 = Data.Blocks[i + 1].Pitch;
								// double d2 = Data.BlockInterval;
								// c2 = d2 / Math.Sqrt(1.0 + p2 * p2);
								// h2 = c2 * p2;
								// }

								//These generate a compiler warning, as secondary tracks do not generate yaw, as they have no
								//concept of a curve, but rather are a straight line between two points
								//TODO: Revist the handling of secondary tracks ==> !!BACKWARDS INCOMPATIBLE!!
								/*
								double TrackYaw2 = Math.Atan2(Direction2.X, Direction2.Y);
								double TrackPitch2 = Math.Atan(Data.Blocks[i + 1].Pitch);
								Transformation GroundTransformation2 = new Transformation(TrackYaw2, 0.0, 0.0);
								Transformation TrackTransformation2 = new Transformation(TrackYaw2, TrackPitch2, 0.0);
								 */
								double x2 = Data.Blocks[i + 1].Rails[j].RailEnd.X;
								double y2 = Data.Blocks[i + 1].Rails[j].RailEnd.Y;
								Vector3 offset2 = new Vector3(Direction2.Y * x2, y2, -Direction2.X * x2);
								Vector3 pos2 = Position2 + offset2;
								Vector3 r = new Vector3(pos2.X - pos.X, pos2.Y - pos.Y, pos2.Z - pos.Z);
								r.Normalize();
								RailTransformation.Z = r;
								RailTransformation.X = new Vector3(r.Z, 0.0, -r.X);
								Normalize(ref RailTransformation.X.X, ref RailTransformation.X.Z);
								RailTransformation.Y = Vector3.Cross(RailTransformation.Z, RailTransformation.X);
								double dx = Data.Blocks[i + 1].Rails[j].RailEnd.X - Data.Blocks[i].Rails[j].RailStart.X;
								double dy = Data.Blocks[i + 1].Rails[j].RailEnd.Y - Data.Blocks[i].Rails[j].RailStart.Y;
								planar = Math.Atan(dx / c);
								updown = Math.Atan(dy / c);
							}
							else
							{
								planar = 0.0;
								updown = 0.0;
								RailTransformation = new Transformation(TrackTransformation, 0.0, 0.0, 0.0);
							}

							CurrentRoute.Tracks[j].Elements[n].StartingTrackPosition = StartingDistance;
							CurrentRoute.Tracks[j].Elements[n].WorldPosition = pos;
							CurrentRoute.Tracks[j].Elements[n].WorldDirection = RailTransformation.Z;
							CurrentRoute.Tracks[j].Elements[n].WorldSide = RailTransformation.X;
							CurrentRoute.Tracks[j].Elements[n].WorldUp = RailTransformation.Y;
							CurrentRoute.Tracks[j].Elements[n].CurveCant = Data.Blocks[i].Rails[j].CurveCant;
							CurrentRoute.Tracks[j].Elements[n].AdhesionMultiplier = Data.Blocks[i].AdhesionMultiplier;
						}
						if (Data.Structure.RailObjects.ContainsKey(Data.Blocks[i].RailType[j]))
						{
							if (Data.Structure.RailObjects[Data.Blocks[i].RailType[j]] != null)
							{
								Data.Structure.RailObjects[Data.Blocks[i].RailType[j]].CreateObject(pos, RailTransformation, Transformation.NullTransformation, Data.AccurateObjectDisposal, StartingDistance, EndingDistance, Data.BlockInterval, StartingDistance);
							}
						}
						// points of interest
						for (int k = 0; k < Data.Blocks[i].PointsOfInterest.Length; k++)
						{
							if (Data.Blocks[i].PointsOfInterest[k].RailIndex == j)
							{
								double d = Data.Blocks[i].PointsOfInterest[k].TrackPosition - StartingDistance;
								double x = Data.Blocks[i].PointsOfInterest[k].Position.X;
								double y = Data.Blocks[i].PointsOfInterest[k].Position.Y;
								int m = CurrentRoute.PointsOfInterest.Length;
								Array.Resize(ref CurrentRoute.PointsOfInterest, m + 1);
								CurrentRoute.PointsOfInterest[m].TrackPosition = Data.Blocks[i].PointsOfInterest[k].TrackPosition;
								if (i < Data.Blocks.Length - 1 && Data.Blocks[i + 1].Rails.ContainsKey(j))
								{
									double dx = Data.Blocks[i + 1].Rails[j].RailEnd.X - Data.Blocks[i].Rails[j].RailStart.X;
									double dy = Data.Blocks[i + 1].Rails[j].RailEnd.Y - Data.Blocks[i].Rails[j].RailStart.Y;
									dx = Data.Blocks[i].Rails[j].RailStart.X + d / Data.BlockInterval * dx;
									dy = Data.Blocks[i].Rails[j].RailStart.Y + d / Data.BlockInterval * dy;
									CurrentRoute.PointsOfInterest[m].TrackOffset = new Vector3(x + dx, y + dy, 0.0);
								}
								else
								{
									double dx = Data.Blocks[i].Rails[j].RailStart.X;
									double dy = Data.Blocks[i].Rails[j].RailStart.Y;
									CurrentRoute.PointsOfInterest[m].TrackOffset = new Vector3(x + dx, y + dy, 0.0);
								}
								CurrentRoute.PointsOfInterest[m].TrackYaw = Data.Blocks[i].PointsOfInterest[k].Yaw + planar;
								CurrentRoute.PointsOfInterest[m].TrackPitch = Data.Blocks[i].PointsOfInterest[k].Pitch + updown;
								CurrentRoute.PointsOfInterest[m].TrackRoll = Data.Blocks[i].PointsOfInterest[k].Roll;
								CurrentRoute.PointsOfInterest[m].Text = Data.Blocks[i].PointsOfInterest[k].Text;
							}
						}
						// poles
						if (Data.Blocks[i].RailPole.Length > j && Data.Blocks[i].RailPole[j].Exists)
						{
							Data.Blocks[i].RailPole[j].Create(Data.Structure.Poles, pos, RailTransformation, Direction, planar, updown, StartingDistance, EndingDistance, Data.BlockInterval, Data.AccurateObjectDisposal);
						}
						// walls
						if (Data.Blocks[i].RailWall.Length > j && Data.Blocks[i].RailWall[j] != null && Data.Blocks[i].RailWall[j].Exists)
						{
							if (Data.Blocks[i].RailWall[j].Direction <= 0)
							{
								Data.Structure.WallL[Data.Blocks[i].RailWall[j].Type].CreateObject(pos, RailTransformation, Transformation.NullTransformation, Data.AccurateObjectDisposal, StartingDistance, EndingDistance, Data.BlockInterval, StartingDistance);
							}
							if (Data.Blocks[i].RailWall[j].Direction >= 0)
							{
								Data.Structure.WallR[Data.Blocks[i].RailWall[j].Type].CreateObject(pos, RailTransformation, Transformation.NullTransformation, Data.AccurateObjectDisposal, StartingDistance, EndingDistance, Data.BlockInterval, StartingDistance);
							}
						}
						// dikes
						if (Data.Blocks[i].RailDike.Length > j && Data.Blocks[i].RailDike[j] != null && Data.Blocks[i].RailDike[j].Exists)
						{
							if (Data.Blocks[i].RailDike[j].Direction <= 0)
							{
								Data.Structure.DikeL[Data.Blocks[i].RailDike[j].Type].CreateObject(pos, RailTransformation, Transformation.NullTransformation, Data.AccurateObjectDisposal, StartingDistance, EndingDistance, Data.BlockInterval, StartingDistance);
							}
							if (Data.Blocks[i].RailDike[j].Direction >= 0)
							{
								Data.Structure.DikeR[Data.Blocks[i].RailDike[j].Type].CreateObject(pos, RailTransformation, Transformation.NullTransformation, Data.AccurateObjectDisposal, StartingDistance, EndingDistance, Data.BlockInterval, StartingDistance);
							}
						}
						// sounds
						if (j == 0)
						{
							for (int k = 0; k < Data.Blocks[i].SoundEvents.Length; k++)
							{
								Data.Blocks[i].SoundEvents[k].Create(pos, StartingDistance, Direction, planar, updown);
							}
						}
						// forms
						for (int k = 0; k < Data.Blocks[i].Forms.Length; k++)
						{
							// primary rail
							if (Data.Blocks[i].Forms[k].PrimaryRail == j)
							{
								if (Data.Blocks[i].Forms[k].SecondaryRail == Form.SecondaryRailStub)
								{
									if (!Data.Structure.FormL.ContainsKey(Data.Blocks[i].Forms[k].FormType))
									{
										Plugin.CurrentHost.AddMessage(MessageType.Error, false, "FormStructureIndex references a FormL not loaded in Track.Form at track position " + StartingDistance.ToString(Culture) + " in file " + FileName + ".");
									}
									else
									{
										Data.Structure.FormL[Data.Blocks[i].Forms[k].FormType].CreateObject(pos, RailTransformation, Transformation.NullTransformation, Data.AccurateObjectDisposal, StartingDistance, EndingDistance, Data.BlockInterval, StartingDistance);
										if (Data.Blocks[i].Forms[k].RoofType > 0)
										{
											if (!Data.Structure.RoofL.ContainsKey(Data.Blocks[i].Forms[k].RoofType))
											{
												Plugin.CurrentHost.AddMessage(MessageType.Error, false, "RoofStructureIndex references a RoofL not loaded in Track.Form at track position " + StartingDistance.ToString(Culture) + " in file " + FileName + ".");
											}
											else
											{
												Data.Structure.RoofL[Data.Blocks[i].Forms[k].RoofType].CreateObject(pos, RailTransformation, Transformation.NullTransformation, Data.AccurateObjectDisposal, StartingDistance, EndingDistance, Data.BlockInterval, StartingDistance);
											}
										}
									}
								}
								else if (Data.Blocks[i].Forms[k].SecondaryRail == Form.SecondaryRailL)
								{
									if (!Data.Structure.FormL.ContainsKey(Data.Blocks[i].Forms[k].FormType))
									{
										Plugin.CurrentHost.AddMessage(MessageType.Error, false, "FormStructureIndex references a FormL not loaded in Track.Form at track position " + StartingDistance.ToString(Culture) + " in file " + FileName + ".");
									}
									else
									{
										Data.Structure.FormL[Data.Blocks[i].Forms[k].FormType].CreateObject(pos, RailTransformation, Transformation.NullTransformation, Data.AccurateObjectDisposal, StartingDistance, EndingDistance, Data.BlockInterval, StartingDistance);
									}
									if (!Data.Structure.FormCL.ContainsKey(Data.Blocks[i].Forms[k].FormType))
									{
										Plugin.CurrentHost.AddMessage(MessageType.Error, false, "FormStructureIndex references a FormCL not loaded in Track.Form at track position " + StartingDistance.ToString(Culture) + " in file " + FileName + ".");
									}
									else
									{
										Plugin.CurrentHost.CreateStaticObject((StaticObject)Data.Structure.FormCL[Data.Blocks[i].Forms[k].FormType], pos, RailTransformation, Transformation.NullTransformation, Data.AccurateObjectDisposal, 0.0, StartingDistance, EndingDistance, Data.BlockInterval, StartingDistance, 1.0);
									}
									if (Data.Blocks[i].Forms[k].RoofType > 0)
									{
										if (!Data.Structure.RoofL.ContainsKey(Data.Blocks[i].Forms[k].RoofType))
										{
											Plugin.CurrentHost.AddMessage(MessageType.Error, false, "RoofStructureIndex references a RoofL not loaded in Track.Form at track position " + StartingDistance.ToString(Culture) + " in file " + FileName + ".");
										}
										else
										{
											Data.Structure.RoofL[Data.Blocks[i].Forms[k].RoofType].CreateObject(pos, RailTransformation, Transformation.NullTransformation, Data.AccurateObjectDisposal, StartingDistance, EndingDistance, Data.BlockInterval, StartingDistance);
										}
										if (!Data.Structure.RoofCL.ContainsKey(Data.Blocks[i].Forms[k].RoofType))
										{
											Plugin.CurrentHost.AddMessage(MessageType.Error, false, "RoofStructureIndex references a RoofCL not loaded in Track.Form at track position " + StartingDistance.ToString(Culture) + " in file " + FileName + ".");
										}
										else
										{
											Plugin.CurrentHost.CreateStaticObject((StaticObject)Data.Structure.RoofCL[Data.Blocks[i].Forms[k].RoofType], pos, RailTransformation, Transformation.NullTransformation, Data.AccurateObjectDisposal, 0.0, StartingDistance, EndingDistance, Data.BlockInterval, StartingDistance, 1.0);
										}
									}
								}
								else if (Data.Blocks[i].Forms[k].SecondaryRail == Form.SecondaryRailR)
								{
									if (!Data.Structure.FormR.ContainsKey(Data.Blocks[i].Forms[k].FormType))
									{
										Plugin.CurrentHost.AddMessage(MessageType.Error, false, "FormStructureIndex references a FormR not loaded in Track.Form at track position " + StartingDistance.ToString(Culture) + " in file " + FileName + ".");
									}
									else
									{
										Data.Structure.FormR[Data.Blocks[i].Forms[k].FormType].CreateObject(pos, RailTransformation, Transformation.NullTransformation, Data.AccurateObjectDisposal, StartingDistance, EndingDistance, Data.BlockInterval, StartingDistance);
									}
									if (!Data.Structure.FormCR.ContainsKey(Data.Blocks[i].Forms[k].FormType))
									{
										Plugin.CurrentHost.AddMessage(MessageType.Error, false, "FormStructureIndex references a FormCR not loaded in Track.Form at track position " + StartingDistance.ToString(Culture) + " in file " + FileName + ".");
									}
									else
									{
										Plugin.CurrentHost.CreateStaticObject((StaticObject)Data.Structure.FormCR[Data.Blocks[i].Forms[k].FormType], pos, RailTransformation, Transformation.NullTransformation, Data.AccurateObjectDisposal, 0.0, StartingDistance, EndingDistance, Data.BlockInterval, StartingDistance, 1.0);
									}
									if (Data.Blocks[i].Forms[k].RoofType > 0)
									{
										if (!Data.Structure.RoofR.ContainsKey(Data.Blocks[i].Forms[k].RoofType))
										{
											Plugin.CurrentHost.AddMessage(MessageType.Error, false, "RoofStructureIndex references a RoofR not loaded in Track.Form at track position " + StartingDistance.ToString(Culture) + " in file " + FileName + ".");
										}
										else
										{
											Data.Structure.RoofR[Data.Blocks[i].Forms[k].RoofType].CreateObject(pos, RailTransformation, Transformation.NullTransformation, Data.AccurateObjectDisposal, StartingDistance, EndingDistance, Data.BlockInterval, StartingDistance);
										}
										if (!Data.Structure.RoofCR.ContainsKey(Data.Blocks[i].Forms[k].RoofType))
										{
											Plugin.CurrentHost.AddMessage(MessageType.Error, false, "RoofStructureIndex references a RoofCR not loaded in Track.Form at track position " + StartingDistance.ToString(Culture) + " in file " + FileName + ".");
										}
										else
										{
											Plugin.CurrentHost.CreateStaticObject((StaticObject)Data.Structure.RoofCR[Data.Blocks[i].Forms[k].RoofType], pos, RailTransformation, Transformation.NullTransformation, Data.AccurateObjectDisposal, 0.0, StartingDistance, EndingDistance, Data.BlockInterval, StartingDistance, 1.0);
										}
									}
								}
								else if (Data.Blocks[i].Forms[k].SecondaryRail > 0)
								{
									int p = Data.Blocks[i].Forms[k].PrimaryRail;
									double px0 = p > 0 ? Data.Blocks[i].Rails[p].RailStart.X : 0.0;
									double px1 = p > 0 ? Data.Blocks[i + 1].Rails[p].RailEnd.X : 0.0;
									int s = Data.Blocks[i].Forms[k].SecondaryRail;
									if (s < 0 || !Data.Blocks[i].Rails.ContainsKey(s) || !Data.Blocks[i].Rails[s].RailStarted)
									{
										Plugin.CurrentHost.AddMessage(MessageType.Error, false, "RailIndex2 is out of range in Track.Form at track position " + StartingDistance.ToString(Culture) + " in file " + FileName);
									}
									else
									{
										double sx0 = Data.Blocks[i].Rails[s].RailStart.X;
										double sx1 = Data.Blocks[i + 1].Rails[s].RailEnd.X;
										double d0 = sx0 - px0;
										double d1 = sx1 - px1;
										if (d0 < 0.0)
										{
											if (!Data.Structure.FormL.ContainsKey(Data.Blocks[i].Forms[k].FormType))
											{
												Plugin.CurrentHost.AddMessage(MessageType.Error, false, "FormStructureIndex references a FormL not loaded in Track.Form at track position " + StartingDistance.ToString(Culture) + " in file " + FileName + ".");
											}
											else
											{
												Data.Structure.FormL[Data.Blocks[i].Forms[k].FormType].CreateObject(pos, RailTransformation, Transformation.NullTransformation, Data.AccurateObjectDisposal, StartingDistance, EndingDistance, Data.BlockInterval, StartingDistance);
											}
											if (!Data.Structure.FormCL.ContainsKey(Data.Blocks[i].Forms[k].FormType))
											{
												Plugin.CurrentHost.AddMessage(MessageType.Error, false, "FormStructureIndex references a FormCL not loaded in Track.Form at track position " + StartingDistance.ToString(Culture) + " in file " + FileName + ".");
											}
											else
											{
												StaticObject FormC = (StaticObject)Data.Structure.FormCL[Data.Blocks[i].Forms[k].FormType].Transform(d0, d1);
												Plugin.CurrentHost.CreateStaticObject(FormC, pos, RailTransformation, Transformation.NullTransformation, Data.AccurateObjectDisposal, 0.0, StartingDistance, EndingDistance, Data.BlockInterval, StartingDistance, 1.0);
											}
											if (Data.Blocks[i].Forms[k].RoofType > 0)
											{
												if (!Data.Structure.RoofL.ContainsKey(Data.Blocks[i].Forms[k].RoofType))
												{
													Plugin.CurrentHost.AddMessage(MessageType.Error, false, "RoofStructureIndex references a RoofL not loaded in Track.Form at track position " + StartingDistance.ToString(Culture) + " in file " + FileName + ".");
												}
												else
												{
													Data.Structure.RoofL[Data.Blocks[i].Forms[k].RoofType].CreateObject(pos, RailTransformation, Transformation.NullTransformation, Data.AccurateObjectDisposal, StartingDistance, EndingDistance, Data.BlockInterval, StartingDistance);
												}
												if (!Data.Structure.RoofCL.ContainsKey(Data.Blocks[i].Forms[k].RoofType))
												{
													Plugin.CurrentHost.AddMessage(MessageType.Error, false, "RoofStructureIndex references a RoofCL not loaded in Track.Form at track position " + StartingDistance.ToString(Culture) + " in file " + FileName + ".");
												}
												else
												{
													StaticObject RoofC = (StaticObject)Data.Structure.RoofCL[Data.Blocks[i].Forms[k].RoofType].Transform(d0, d1);
													Plugin.CurrentHost.CreateStaticObject(RoofC, pos, RailTransformation, Transformation.NullTransformation, Data.AccurateObjectDisposal, 0.0, StartingDistance, EndingDistance, Data.BlockInterval, StartingDistance, 1.0);
												}
											}
										}
										else if (d0 > 0.0)
										{
											if (!Data.Structure.FormR.ContainsKey(Data.Blocks[i].Forms[k].FormType))
											{
												Plugin.CurrentHost.AddMessage(MessageType.Error, false, "FormStructureIndex references a FormR not loaded in Track.Form at track position " + StartingDistance.ToString(Culture) + " in file " + FileName + ".");
											}
											else
											{
												Data.Structure.FormR[Data.Blocks[i].Forms[k].FormType].CreateObject(pos, RailTransformation, Transformation.NullTransformation, Data.AccurateObjectDisposal, StartingDistance, EndingDistance, Data.BlockInterval, StartingDistance);
											}
											if (!Data.Structure.FormCR.ContainsKey(Data.Blocks[i].Forms[k].FormType))
											{
												Plugin.CurrentHost.AddMessage(MessageType.Error, false, "FormStructureIndex references a FormCR not loaded in Track.Form at track position " + StartingDistance.ToString(Culture) + " in file " + FileName + ".");
											}
											else
											{
												StaticObject FormC = (StaticObject)Data.Structure.FormCR[Data.Blocks[i].Forms[k].FormType].Transform(d0, d1);
												Plugin.CurrentHost.CreateStaticObject(FormC, pos, RailTransformation, Transformation.NullTransformation, Data.AccurateObjectDisposal, 0.0, StartingDistance, EndingDistance, Data.BlockInterval, StartingDistance, 1.0);
											}
											if (Data.Blocks[i].Forms[k].RoofType > 0)
											{
												if (!Data.Structure.RoofR.ContainsKey(Data.Blocks[i].Forms[k].RoofType))
												{
													Plugin.CurrentHost.AddMessage(MessageType.Error, false, "RoofStructureIndex references a RoofR not loaded in Track.Form at track position " + StartingDistance.ToString(Culture) + " in file " + FileName + ".");
												}
												else
												{
													Data.Structure.RoofR[Data.Blocks[i].Forms[k].RoofType].CreateObject(pos, RailTransformation, Transformation.NullTransformation, Data.AccurateObjectDisposal, StartingDistance, EndingDistance, Data.BlockInterval, StartingDistance);
												}
												if (!Data.Structure.RoofCR.ContainsKey(Data.Blocks[i].Forms[k].RoofType))
												{
													Plugin.CurrentHost.AddMessage(MessageType.Error, false, "RoofStructureIndex references a RoofCR not loaded in Track.Form at track position " + StartingDistance.ToString(Culture) + " in file " + FileName + ".");
												}
												else
												{
													StaticObject RoofC = (StaticObject)Data.Structure.RoofCR[Data.Blocks[i].Forms[k].RoofType].Transform(d0, d1);
													Plugin.CurrentHost.CreateStaticObject(RoofC, pos, RailTransformation, Transformation.NullTransformation, Data.AccurateObjectDisposal, 0.0, StartingDistance, EndingDistance, Data.BlockInterval, StartingDistance, 1.0);
												}
											}
										}
									}
								}
							}
							// secondary rail
							if (Data.Blocks[i].Forms[k].SecondaryRail == j)
							{
								int p = Data.Blocks[i].Forms[k].PrimaryRail;
								double px = p > 0 ? Data.Blocks[i].Rails[p].RailStart.X : 0.0;
								int s = Data.Blocks[i].Forms[k].SecondaryRail;
								double sx = Data.Blocks[i].Rails[s].RailStart.X;
								double d = px - sx;
								if (d < 0.0)
								{
									if (!Data.Structure.FormL.ContainsKey(Data.Blocks[i].Forms[k].FormType))
									{
										Plugin.CurrentHost.AddMessage(MessageType.Error, false, "FormStructureIndex references a FormL not loaded in Track.Form at track position " + StartingDistance.ToString(Culture) + " in file " + FileName + ".");
									}
									else
									{
										Data.Structure.FormL[Data.Blocks[i].Forms[k].FormType].CreateObject(pos, RailTransformation, Transformation.NullTransformation, Data.AccurateObjectDisposal, StartingDistance, EndingDistance, Data.BlockInterval, StartingDistance);
									}
									if (Data.Blocks[i].Forms[k].RoofType > 0)
									{
										if (!Data.Structure.RoofL.ContainsKey(Data.Blocks[i].Forms[k].RoofType))
										{
											Plugin.CurrentHost.AddMessage(MessageType.Error, false, "RoofStructureIndex references a RoofL not loaded in Track.Form at track position " + StartingDistance.ToString(Culture) + " in file " + FileName + ".");
										}
										else
										{
											Data.Structure.RoofL[Data.Blocks[i].Forms[k].RoofType].CreateObject(pos, RailTransformation, Transformation.NullTransformation, Data.AccurateObjectDisposal, StartingDistance, EndingDistance, Data.BlockInterval, StartingDistance);
										}
									}
								}
								else
								{
									if (!Data.Structure.FormR.ContainsKey(Data.Blocks[i].Forms[k].FormType))
									{
										Plugin.CurrentHost.AddMessage(MessageType.Error, false, "FormStructureIndex references a FormR not loaded in Track.Form at track position " + StartingDistance.ToString(Culture) + " in file " + FileName + ".");
									}
									else
									{
										Data.Structure.FormR[Data.Blocks[i].Forms[k].FormType].CreateObject(pos, RailTransformation, Transformation.NullTransformation, Data.AccurateObjectDisposal, StartingDistance, EndingDistance, Data.BlockInterval, StartingDistance);
									}
									if (Data.Blocks[i].Forms[k].RoofType > 0)
									{
										if (!Data.Structure.RoofR.ContainsKey(Data.Blocks[i].Forms[k].RoofType))
										{
											Plugin.CurrentHost.AddMessage(MessageType.Error, false, "RoofStructureIndex references a RoofR not loaded in Track.Form at track position " + StartingDistance.ToString(Culture) + " in file " + FileName + ".");
										}
										else
										{
											Data.Structure.RoofR[Data.Blocks[i].Forms[k].RoofType].CreateObject(pos, RailTransformation, Transformation.NullTransformation, Data.AccurateObjectDisposal, StartingDistance, EndingDistance, Data.BlockInterval, StartingDistance);
										}
									}
								}
							}
						}
						// cracks
						for (int k = 0; k < Data.Blocks[i].Cracks.Length; k++)
						{
							if (Data.Blocks[i].Cracks[k].PrimaryRail == j)
							{
								int p = Data.Blocks[i].Cracks[k].PrimaryRail;
								double px0 = p > 0 ? Data.Blocks[i].Rails[p].RailStart.X : 0.0;
								double px1 = p > 0 ? Data.Blocks[i + 1].Rails[p].RailEnd.X : 0.0;
								int s = Data.Blocks[i].Cracks[k].SecondaryRail;
								if (s < 0 || !Data.Blocks[i].Rails.ContainsKey(s) || !Data.Blocks[i].Rails[s].RailStarted)
								{
									Plugin.CurrentHost.AddMessage(MessageType.Error, false, "RailIndex2 is out of range in Track.Crack at track position " + StartingDistance.ToString(Culture) + " in file " + FileName);
								}
								else
								{
									double sx0 = Data.Blocks[i].Rails[s].RailStart.X;
									double sx1 = Data.Blocks[i + 1].Rails[s].RailEnd.X;
									double d0 = sx0 - px0;
									double d1 = sx1 - px1;
									if (d0 < 0.0)
									{
										if (!Data.Structure.CrackL.ContainsKey(Data.Blocks[i].Cracks[k].Type))
										{
											Plugin.CurrentHost.AddMessage(MessageType.Error, false, "CrackStructureIndex references a CrackL not loaded in Track.Crack at track position " + StartingDistance.ToString(Culture) + " in file " + FileName + ".");
										}
										else
										{
											StaticObject Crack = (StaticObject)Data.Structure.CrackL[Data.Blocks[i].Cracks[k].Type].Transform(d0, d1);
											Plugin.CurrentHost.CreateStaticObject(Crack, pos, RailTransformation, Transformation.NullTransformation, Data.AccurateObjectDisposal, 0.0, StartingDistance, EndingDistance, Data.BlockInterval, StartingDistance, 1.0);
										}
									}
									else if (d0 > 0.0)
									{
										if (!Data.Structure.CrackR.ContainsKey(Data.Blocks[i].Cracks[k].Type))
										{
											Plugin.CurrentHost.AddMessage(MessageType.Error, false, "CrackStructureIndex references a CrackR not loaded in Track.Crack at track position " + StartingDistance.ToString(Culture) + " in file " + FileName + ".");
										}
										else
										{
											StaticObject Crack = (StaticObject)Data.Structure.CrackR[Data.Blocks[i].Cracks[k].Type].Transform(d0, d1);
											Plugin.CurrentHost.CreateStaticObject(Crack, pos, RailTransformation, Transformation.NullTransformation, Data.AccurateObjectDisposal, 0.0, StartingDistance, EndingDistance, Data.BlockInterval, StartingDistance, 1.0);
										}
									}
								}
							}
						}
						// free objects
						if (Data.Blocks[i].RailFreeObj.Length > j && Data.Blocks[i].RailFreeObj[j] != null)
						{
							for (int k = 0; k < Data.Blocks[i].RailFreeObj[j].Length; k++)
							{
								Data.Blocks[i].RailFreeObj[j][k].CreateRailAligned(Data.Structure.FreeObjects, new Vector3(pos), RailTransformation, StartingDistance, EndingDistance, Data.BlockInterval, Data.AccurateObjectDisposal);
							}
						}
						// transponder objects
						if (j == 0)
						{
							for (int k = 0; k < Data.Blocks[i].Transponders.Length; k++)
							{
								UnifiedObject obj = null;
								if (Data.Blocks[i].Transponders[k].BeaconStructureIndex == -2)
								{
									switch (Data.Blocks[i].Transponders[k].Type)
									{
										case 0: obj = CompatibilityObjects.TransponderS; break;
										case 1: obj = CompatibilityObjects.TransponderSN; break;
										case 2: obj = CompatibilityObjects.TransponderFalseStart; break;
										case 3: obj = CompatibilityObjects.TransponderPOrigin; break;
										case 4: obj = CompatibilityObjects.TransponderPStop; break;
									}
								}
								else
								{
									int b = Data.Blocks[i].Transponders[k].BeaconStructureIndex;
									if (b >= 0 & Data.Structure.Beacon.ContainsKey(b))
									{
										obj = Data.Structure.Beacon[b];
									}
								}
								if (obj != null)
								{
									double dx = Data.Blocks[i].Transponders[k].Position.X;
									double dy = Data.Blocks[i].Transponders[k].Position.Y;
									double dz = Data.Blocks[i].Transponders[k].TrackPosition - StartingDistance;
									Vector3 wpos = pos;
									wpos += dx * RailTransformation.X + dy * RailTransformation.Y + dz * RailTransformation.Z;
									double tpos = Data.Blocks[i].Transponders[k].TrackPosition;
									if (Data.Blocks[i].Transponders[k].BeaconStructureIndex == -2)
									{
										double b = 0.25 + 0.75 * GetBrightness(ref Data, tpos);
										obj.CreateObject(wpos, RailTransformation, new Transformation(Data.Blocks[i].Transponders[k].Yaw, Data.Blocks[i].Transponders[k].Pitch, Data.Blocks[i].Transponders[k].Roll), -1, Data.AccurateObjectDisposal, StartingDistance, EndingDistance, Data.BlockInterval, tpos, b, false);
									}
									else
									{
										obj.CreateObject(wpos, RailTransformation, new Transformation(Data.Blocks[i].Transponders[k].Yaw, Data.Blocks[i].Transponders[k].Pitch, Data.Blocks[i].Transponders[k].Roll), Data.AccurateObjectDisposal, StartingDistance, EndingDistance, Data.BlockInterval, tpos);
									}
								}
							}
							for (int k = 0; k < Data.Blocks[i].DestinationChanges.Length; k++)
							{
								UnifiedObject obj = null;
								int b = Data.Blocks[i].DestinationChanges[k].BeaconStructureIndex;
								if (b >= 0 & Data.Structure.Beacon.ContainsKey(b))
								{
									obj = Data.Structure.Beacon[b];
								}
								if (obj != null)
								{
									double dx = Data.Blocks[i].DestinationChanges[k].Position.X;
									double dy = Data.Blocks[i].DestinationChanges[k].Position.Y;
									double dz = Data.Blocks[i].DestinationChanges[k].TrackPosition - StartingDistance;
									Vector3 wpos = pos;
									wpos += dx * RailTransformation.X + dy * RailTransformation.Y + dz * RailTransformation.Z;
									double tpos = Data.Blocks[i].DestinationChanges[k].TrackPosition;
									obj.CreateObject(wpos, RailTransformation, new Transformation(Data.Blocks[i].DestinationChanges[k].Yaw, Data.Blocks[i].DestinationChanges[k].Pitch, Data.Blocks[i].DestinationChanges[k].Roll), Data.AccurateObjectDisposal, StartingDistance, EndingDistance, Data.BlockInterval, tpos);
								}
							}
						}
						// sections/signals/transponders
						if (j == 0)
						{
							// signals
							for (int k = 0; k < Data.Blocks[i].Signals.Length; k++)
							{
								Data.Blocks[i].Signals[k].Create(new Vector3(pos), RailTransformation, Data.AccurateObjectDisposal, StartingDistance, EndingDistance, Data.BlockInterval, 0.27 + 0.75 * GetBrightness(ref Data, Data.Blocks[i].Signals[k].TrackPosition));
							}
							// sections
							for (int k = 0; k < Data.Blocks[i].Sections.Length; k++)
							{
								Data.Blocks[i].Sections[k].Create(CurrentRoute, Data.Blocks, i, n, Data.SignalSpeeds, StartingDistance, Data.BlockInterval);
							}
							// transponders introduced after corresponding sections
							for (int l = 0; l < Data.Blocks[i].Transponders.Length; l++)
							{
								if (Data.Blocks[i].Transponders[l].Type != -1)
								{
									int t = Data.Blocks[i].Transponders[l].SectionIndex;
									if (t >= 0 & t < CurrentRoute.Sections.Length)
									{
										int m = CurrentRoute.Tracks[0].Elements[n].Events.Length;
										Array.Resize(ref CurrentRoute.Tracks[0].Elements[n].Events, m + 1);
										double dt = Data.Blocks[i].Transponders[l].TrackPosition - StartingDistance;
										CurrentRoute.Tracks[0].Elements[n].Events[m] = new TransponderEvent(CurrentRoute, dt, Data.Blocks[i].Transponders[l].Type, Data.Blocks[i].Transponders[l].Data, t, Data.Blocks[i].Transponders[l].ClipToFirstRedSection);
										Data.Blocks[i].Transponders[l].Type = -1;
									}
								}
							}
						}
						// limit
						if (j == 0)
						{
							for (int k = 0; k < Data.Blocks[i].Limits.Length; k++)
							{
								if (Data.Blocks[i].Limits[k].Direction != 0)
								{
									double dx = 2.2 * Data.Blocks[i].Limits[k].Direction;
									double dz = Data.Blocks[i].Limits[k].TrackPosition - StartingDistance;
									Vector3 wpos = pos;
									wpos += dx * RailTransformation.X + dz * RailTransformation.Z;
									double tpos = Data.Blocks[i].Limits[k].TrackPosition;
									double b = 0.25 + 0.75 * GetBrightness(ref Data, tpos);
									if (Data.Blocks[i].Limits[k].Speed <= 0.0 | Data.Blocks[i].Limits[k].Speed >= 1000.0)
									{
										CompatibilityObjects.LimitPostInfinite.CreateObject(wpos, RailTransformation, Transformation.NullTransformation, -1, Data.AccurateObjectDisposal, StartingDistance, EndingDistance, Data.BlockInterval, tpos, b, false);
									}
									else
									{
										if (Data.Blocks[i].Limits[k].Cource < 0)
										{
											CompatibilityObjects.LimitPostLeft.CreateObject(wpos, RailTransformation, Transformation.NullTransformation, -1, Data.AccurateObjectDisposal, StartingDistance, EndingDistance, Data.BlockInterval, tpos, b, false);
										}
										else if (Data.Blocks[i].Limits[k].Cource > 0)
										{
											CompatibilityObjects.LimitPostRight.CreateObject(wpos, RailTransformation, Transformation.NullTransformation, -1, Data.AccurateObjectDisposal, StartingDistance, EndingDistance, Data.BlockInterval, tpos, b, false);
										}
										else
										{
											CompatibilityObjects.LimitPostStraight.CreateObject(wpos, RailTransformation, Transformation.NullTransformation, -1, Data.AccurateObjectDisposal, StartingDistance, EndingDistance, Data.BlockInterval, tpos, b, false);
										}
										double lim = Data.Blocks[i].Limits[k].Speed / Data.UnitOfSpeed;
										if (lim < 10.0)
										{
											int d0 = (int)Math.Round(lim);
											if (CompatibilityObjects.LimitOneDigit is StaticObject)
											{
												StaticObject o = (StaticObject) CompatibilityObjects.LimitOneDigit.Clone();
												if (o.Mesh.Materials.Length >= 1)
												{
													Plugin.CurrentHost.RegisterTexture(OpenBveApi.Path.CombineFile(LimitGraphicsPath, "limit_" + d0 + ".png"), new TextureParameters(null, null), out o.Mesh.Materials[0].DaytimeTexture);
												}
												o.CreateObject(wpos, RailTransformation, Transformation.NullTransformation, -1, Data.AccurateObjectDisposal, StartingDistance, EndingDistance, Data.BlockInterval, tpos, b, false);
											}
											else
											{
												Plugin.CurrentHost.AddMessage(MessageType.Error, false, "Attempted to use an animated object for LimitOneDigit, where only static objects are allowed.");
											}
											
										}
										else if (lim < 100.0)
										{
											int d1 = (int)Math.Round(lim);
											int d0 = d1 % 10;
											d1 /= 10;
											if (CompatibilityObjects.LimitTwoDigits is StaticObject)
											{
												StaticObject o = (StaticObject) CompatibilityObjects.LimitTwoDigits.Clone();
												if (o.Mesh.Materials.Length >= 1)
												{
													Plugin.CurrentHost.RegisterTexture(OpenBveApi.Path.CombineFile(LimitGraphicsPath, "limit_" + d1 + ".png"), new TextureParameters(null, null), out o.Mesh.Materials[0].DaytimeTexture);
												}
												if (o.Mesh.Materials.Length >= 2)
												{
													Plugin.CurrentHost.RegisterTexture(OpenBveApi.Path.CombineFile(LimitGraphicsPath, "limit_" + d0 + ".png"), new TextureParameters(null, null), out o.Mesh.Materials[1].DaytimeTexture);
												}
												o.CreateObject(wpos, RailTransformation, Transformation.NullTransformation, -1, Data.AccurateObjectDisposal, StartingDistance, EndingDistance, Data.BlockInterval, tpos, b, false);
											}
											else
											{
												Plugin.CurrentHost.AddMessage(MessageType.Error, false, "Attempted to use an animated object for LimitTwoDigits, where only static objects are allowed.");
											}
										}
										else
										{
											int d2 = (int)Math.Round(lim);
											int d0 = d2 % 10;
											int d1 = (d2 / 10) % 10;
											d2 /= 100;
											if (CompatibilityObjects.LimitThreeDigits is StaticObject)
											{
												StaticObject o = (StaticObject) CompatibilityObjects.LimitThreeDigits.Clone();
												if (o.Mesh.Materials.Length >= 1)
												{
													Plugin.CurrentHost.RegisterTexture(OpenBveApi.Path.CombineFile(LimitGraphicsPath, "limit_" + d2 + ".png"), new TextureParameters(null, null), out o.Mesh.Materials[0].DaytimeTexture);
												}
												if (o.Mesh.Materials.Length >= 2)
												{
													Plugin.CurrentHost.RegisterTexture(OpenBveApi.Path.CombineFile(LimitGraphicsPath, "limit_" + d1 + ".png"), new TextureParameters(null, null), out o.Mesh.Materials[1].DaytimeTexture);
												}
												if (o.Mesh.Materials.Length >= 3)
												{
													Plugin.CurrentHost.RegisterTexture(OpenBveApi.Path.CombineFile(LimitGraphicsPath, "limit_" + d0 + ".png"), new TextureParameters(null, null), out o.Mesh.Materials[2].DaytimeTexture);
												}
												o.CreateObject(wpos, RailTransformation, Transformation.NullTransformation, -1, Data.AccurateObjectDisposal, StartingDistance, EndingDistance, Data.BlockInterval, tpos, b, false);
											}
											else
											{
												Plugin.CurrentHost.AddMessage(MessageType.Error, false, "Attempted to use an animated object for LimitThreeDigits, where only static objects are allowed.");
											}
										}
									}
								}
							}
						}
						// stop
						if (j == 0)
						{
							for (int k = 0; k < Data.Blocks[i].StopPositions.Length; k++)
							{
								if (Data.Blocks[i].StopPositions[k].Direction != 0)
								{
									double dx = 1.8 * Data.Blocks[i].StopPositions[k].Direction;
									double dz = Data.Blocks[i].StopPositions[k].TrackPosition - StartingDistance;
									Vector3 wpos = pos;
									wpos += dx * RailTransformation.X + dz * RailTransformation.Z;
									double tpos = Data.Blocks[i].StopPositions[k].TrackPosition;
									double b = 0.25 + 0.75 * GetBrightness(ref Data, tpos);
									CompatibilityObjects.StopPost.CreateObject(wpos, RailTransformation, Transformation.NullTransformation, -1, Data.AccurateObjectDisposal, StartingDistance, EndingDistance, Data.BlockInterval, tpos, b, false);
								}
							}
						}
					}
				}
				// finalize block
				Position.X += Direction.X * c;
				Position.Y += h;
				Position.Z += Direction.Y * c;
				if (a != 0.0)
				{
					Direction.Rotate(Math.Cos(-a), Math.Sin(-a));
				}
			}
			// orphaned transponders
			if (!PreviewOnly)
			{
				for (int i = Data.FirstUsedBlock; i < Data.Blocks.Length; i++)
				{
					for (int j = 0; j < Data.Blocks[i].Transponders.Length; j++)
					{
						if (Data.Blocks[i].Transponders[j].Type != -1)
						{
							int n = i - Data.FirstUsedBlock;
							int m = CurrentRoute.Tracks[0].Elements[n].Events.Length;
							Array.Resize(ref CurrentRoute.Tracks[0].Elements[n].Events, m + 1);
							double d = Data.Blocks[i].Transponders[j].TrackPosition - CurrentRoute.Tracks[0].Elements[n].StartingTrackPosition;
							int s = Data.Blocks[i].Transponders[j].SectionIndex;
							if (s >= 0) s = -1;
							CurrentRoute.Tracks[0].Elements[n].Events[m] = new TransponderEvent(CurrentRoute, d, Data.Blocks[i].Transponders[j].Type, Data.Blocks[i].Transponders[j].Data, s, Data.Blocks[i].Transponders[j].ClipToFirstRedSection);
							Data.Blocks[i].Transponders[j].Type = -1;
						}
					}
					// Destination Change Events
					for (int j = 0; j < Data.Blocks[i].DestinationChanges.Length; j++)
					{
						int n = i - Data.FirstUsedBlock;
						int m = CurrentRoute.Tracks[0].Elements[n].Events.Length;
						Array.Resize(ref CurrentRoute.Tracks[0].Elements[n].Events, m + 1);
						double d = Data.Blocks[i].DestinationChanges[j].TrackPosition - CurrentRoute.Tracks[0].Elements[n].StartingTrackPosition;
						CurrentRoute.Tracks[0].Elements[n].Events[m] = new RouteManager2.Events.DestinationEvent(d, Data.Blocks[i].DestinationChanges[j].Type, Data.Blocks[i].DestinationChanges[j].NextDestination, Data.Blocks[i].DestinationChanges[j].PreviousDestination, Data.Blocks[i].DestinationChanges[j].TriggerOnce);
					}
				}
			}
			// insert station end events
			for (int i = 0; i < CurrentRoute.Stations.Length; i++)
			{
				int j = CurrentRoute.Stations[i].Stops.Length - 1;
				if (j >= 0)
				{
					double p = CurrentRoute.Stations[i].Stops[j].TrackPosition + CurrentRoute.Stations[i].Stops[j].ForwardTolerance + Data.BlockInterval;
					int k = (int)Math.Floor(p / Data.BlockInterval) - Data.FirstUsedBlock;
					if (k >= 0 & k < Data.Blocks.Length)
					{
						double d = p - (k + Data.FirstUsedBlock) * Data.BlockInterval;
						int m = CurrentRoute.Tracks[0].Elements[k].Events.Length;
						Array.Resize(ref CurrentRoute.Tracks[0].Elements[k].Events, m + 1);
						CurrentRoute.Tracks[0].Elements[k].Events[m] = new StationEndEvent(d, i, CurrentRoute, Plugin.CurrentHost);
					}
				}
			}
			// create default point of interests
			if (CurrentRoute.PointsOfInterest.Length == 0)
			{
				CurrentRoute.PointsOfInterest = new RouteManager2.PointOfInterest[CurrentRoute.Stations.Length];
				int n = 0;
				for (int i = 0; i < CurrentRoute.Stations.Length; i++)
				{
					if (CurrentRoute.Stations[i].Stops.Length != 0)
					{
						CurrentRoute.PointsOfInterest[n].Text = CurrentRoute.Stations[i].Name;
						CurrentRoute.PointsOfInterest[n].TrackPosition = CurrentRoute.Stations[i].Stops[0].TrackPosition;
						CurrentRoute.PointsOfInterest[n].TrackOffset = new Vector3(0.0, 2.8, 0.0);
						if (CurrentRoute.Stations[i].OpenLeftDoors & !CurrentRoute.Stations[i].OpenRightDoors)
						{
							CurrentRoute.PointsOfInterest[n].TrackOffset.X = -2.5;
						}
						else if (!CurrentRoute.Stations[i].OpenLeftDoors & CurrentRoute.Stations[i].OpenRightDoors)
						{
							CurrentRoute.PointsOfInterest[n].TrackOffset.X = 2.5;
						}
						n++;
					}
				}
				Array.Resize(ref CurrentRoute.PointsOfInterest, n);
			}
			// convert block-based cant into point-based cant
			for (int ii = 0; ii < CurrentRoute.Tracks.Count; ii++)
			{
				int i = CurrentRoute.Tracks.ElementAt(ii).Key;
				for (int j = CurrentTrackLength - 1; j >= 1; j--)
				{
					if (CurrentRoute.Tracks[i].Elements[j].CurveCant == 0.0)
					{
						CurrentRoute.Tracks[i].Elements[j].CurveCant = CurrentRoute.Tracks[i].Elements[j - 1].CurveCant;
					}
					else if (CurrentRoute.Tracks[i].Elements[j - 1].CurveCant != 0.0)
					{
						if (Math.Sign(CurrentRoute.Tracks[i].Elements[j - 1].CurveCant) == Math.Sign(CurrentRoute.Tracks[i].Elements[j].CurveCant))
						{
							if (Math.Abs(CurrentRoute.Tracks[i].Elements[j - 1].CurveCant) > Math.Abs(CurrentRoute.Tracks[i].Elements[j].CurveCant))
							{
								CurrentRoute.Tracks[i].Elements[j].CurveCant = CurrentRoute.Tracks[i].Elements[j - 1].CurveCant;
							}
						}
						else
						{
							CurrentRoute.Tracks[i].Elements[j].CurveCant = 0.5 * (CurrentRoute.Tracks[i].Elements[j].CurveCant + CurrentRoute.Tracks[i].Elements[j - 1].CurveCant);
						}
					}
				}
			}
			// finalize
			for (int ii = 0; ii < CurrentRoute.Tracks.Count; ii++)
			{
				int i = CurrentRoute.Tracks.ElementAt(ii).Key;
				Array.Resize(ref CurrentRoute.Tracks[i].Elements, CurrentTrackLength);
			}
			for (int i = 0; i < CurrentRoute.Stations.Length; i++)
			{
				if (CurrentRoute.Stations[i].Stops.Length == 0 & CurrentRoute.Stations[i].StopMode != StationStopMode.AllPass)
				{
					Plugin.CurrentHost.AddMessage(MessageType.Warning, false, "Station " + CurrentRoute.Stations[i].Name + " expects trains to stop but does not define stop points at track position " + CurrentRoute.Stations[i].DefaultTrackPosition.ToString(Culture) + " in file " + FileName);
					CurrentRoute.Stations[i].StopMode = StationStopMode.AllPass;
				}

				switch (CurrentRoute.Stations[i].Type)
				{
					case StationType.ChangeEnds:
						if (i < CurrentRoute.Stations.Length - 1)
						{
							if (CurrentRoute.Stations[i + 1].StopMode != StationStopMode.AllStop)
							{
								Plugin.CurrentHost.AddMessage(MessageType.Warning, false, "Station " + CurrentRoute.Stations[i].Name + " is marked as \"change ends\" but the subsequent station does not expect all trains to stop in file " + FileName);
								CurrentRoute.Stations[i + 1].StopMode = StationStopMode.AllStop;
							}
						}
						else
						{
							Plugin.CurrentHost.AddMessage(MessageType.Warning, false, "Station " + CurrentRoute.Stations[i].Name + " is marked as \"change ends\" but there is no subsequent station defined in file " + FileName);
							CurrentRoute.Stations[i].Type = StationType.Terminal;
						}
						break;
					case StationType.Jump:
						if (CurrentRoute.Stations[i].JumpIndex < CurrentRoute.Stations.Length)
						{
							if (CurrentRoute.Stations[CurrentRoute.Stations[i].JumpIndex].StopMode != StationStopMode.AllStop)
							{
								Plugin.CurrentHost.AddMessage(MessageType.Warning, false, "Station " + CurrentRoute.Stations[i].Name + " is marked as a \"jump trigger\" but the target station does not expect all trains to stop in file " + FileName);
								CurrentRoute.Stations[CurrentRoute.Stations[i].JumpIndex].StopMode = StationStopMode.AllStop;
							}
						}
						else
						{
							Plugin.CurrentHost.AddMessage(MessageType.Warning, false, "Station " + CurrentRoute.Stations[i].Name + " is marked as a \"jump trigger\" but the target station does not exist in file " + FileName);
							CurrentRoute.Stations[i].Type = StationType.Terminal;
						}
						break;
				}
			}
			if (CurrentRoute.Stations.Length != 0)
			{
				CurrentRoute.Stations[CurrentRoute.Stations.Length - 1].Type = StationType.Terminal;
			}
			if (CurrentRoute.Tracks[0].Elements.Length != 0)
			{
				int n = CurrentRoute.Tracks[0].Elements.Length - 1;
				int m = CurrentRoute.Tracks[0].Elements[n].Events.Length;
				Array.Resize(ref CurrentRoute.Tracks[0].Elements[n].Events, m + 1);
				CurrentRoute.Tracks[0].Elements[n].Events[m] = new TrackEndEvent(Plugin.CurrentHost, Data.BlockInterval);
			}
			// insert compatibility beacons
			if (!PreviewOnly)
			{
				List<TransponderEvent> transponders = new List<TransponderEvent>();
				bool atc = false;
				for (int i = 0; i < CurrentRoute.Tracks[0].Elements.Length; i++)
				{
					for (int j = 0; j < CurrentRoute.Tracks[0].Elements[i].Events.Length; j++)
					{
						if (!atc)
						{
							if (CurrentRoute.Tracks[0].Elements[i].Events[j] is StationStartEvent)
							{
								StationStartEvent station = (StationStartEvent)CurrentRoute.Tracks[0].Elements[i].Events[j];
								if (CurrentRoute.Stations[station.StationIndex].SafetySystem == SafetySystem.Atc)
								{
									Array.Resize(ref CurrentRoute.Tracks[0].Elements[i].Events, CurrentRoute.Tracks[0].Elements[i].Events.Length + 2);
									CurrentRoute.Tracks[0].Elements[i].Events[CurrentRoute.Tracks[0].Elements[i].Events.Length - 2] = new TransponderEvent(CurrentRoute, 0.0, TransponderTypes.AtcTrackStatus, 0, 0, false);
									CurrentRoute.Tracks[0].Elements[i].Events[CurrentRoute.Tracks[0].Elements[i].Events.Length - 1] = new TransponderEvent(CurrentRoute, 0.0, TransponderTypes.AtcTrackStatus, 1, 0, false);
									atc = true;
								}
							}
						}
						else
						{
							if (CurrentRoute.Tracks[0].Elements[i].Events[j] is StationStartEvent)
							{
								StationStartEvent station = (StationStartEvent)CurrentRoute.Tracks[0].Elements[i].Events[j];
								if (CurrentRoute.Stations[station.StationIndex].SafetySystem == SafetySystem.Ats)
								{
									Array.Resize(ref CurrentRoute.Tracks[0].Elements[i].Events, CurrentRoute.Tracks[0].Elements[i].Events.Length + 2);
									CurrentRoute.Tracks[0].Elements[i].Events[CurrentRoute.Tracks[0].Elements[i].Events.Length - 2] = new TransponderEvent(CurrentRoute, 0.0, TransponderTypes.AtcTrackStatus, 2, 0, false);
									CurrentRoute.Tracks[0].Elements[i].Events[CurrentRoute.Tracks[0].Elements[i].Events.Length - 1] = new TransponderEvent(CurrentRoute, 0.0, TransponderTypes.AtcTrackStatus, 3, 0, false);
								}
							}
							else if (CurrentRoute.Tracks[0].Elements[i].Events[j] is StationEndEvent)
							{
								StationEndEvent station = (StationEndEvent)CurrentRoute.Tracks[0].Elements[i].Events[j];
								if (CurrentRoute.Stations[station.StationIndex].SafetySystem == SafetySystem.Atc)
								{
									Array.Resize(ref CurrentRoute.Tracks[0].Elements[i].Events, CurrentRoute.Tracks[0].Elements[i].Events.Length + 2);
									CurrentRoute.Tracks[0].Elements[i].Events[CurrentRoute.Tracks[0].Elements[i].Events.Length - 2] = new TransponderEvent(CurrentRoute, 0.0, TransponderTypes.AtcTrackStatus, 1, 0, false);
									CurrentRoute.Tracks[0].Elements[i].Events[CurrentRoute.Tracks[0].Elements[i].Events.Length - 1] = new TransponderEvent(CurrentRoute, 0.0, TransponderTypes.AtcTrackStatus, 2, 0, false);
								}
								else if (CurrentRoute.Stations[station.StationIndex].SafetySystem == SafetySystem.Ats)
								{
									Array.Resize(ref CurrentRoute.Tracks[0].Elements[i].Events, CurrentRoute.Tracks[0].Elements[i].Events.Length + 2);
									CurrentRoute.Tracks[0].Elements[i].Events[CurrentRoute.Tracks[0].Elements[i].Events.Length - 2] = new TransponderEvent(CurrentRoute, 0.0, TransponderTypes.AtcTrackStatus, 3, 0, false);
									CurrentRoute.Tracks[0].Elements[i].Events[CurrentRoute.Tracks[0].Elements[i].Events.Length - 1] = new TransponderEvent(CurrentRoute, 0.0, TransponderTypes.AtcTrackStatus, 0, 0, false);
									atc = false;
								}
							}
							else if (CurrentRoute.Tracks[0].Elements[i].Events[j] is LimitChangeEvent)
							{
								LimitChangeEvent limit = (LimitChangeEvent)CurrentRoute.Tracks[0].Elements[i].Events[j];
								int speed = (int)Math.Round(Math.Min(4095.0, 3.6 * limit.NextSpeedLimit));
								int distance = Math.Min(1048575, (int)Math.Round(CurrentRoute.Tracks[0].Elements[i].StartingTrackPosition + limit.TrackPositionDelta));
								unchecked
								{
									int value = (int)((uint)speed | ((uint)distance << 12));
									transponders.Add(new TransponderEvent(CurrentRoute, 0.0, TransponderTypes.AtcSpeedLimit, value, 0, false));
								}
							}
						}
						if (CurrentRoute.Tracks[0].Elements[i].Events[j] is TransponderEvent)
						{
							TransponderEvent transponder = CurrentRoute.Tracks[0].Elements[i].Events[j] as TransponderEvent;
							if (transponder.Type == (int)TransponderTypes.InternalAtsPTemporarySpeedLimit)
							{
								int speed = Math.Min(4095, transponder.Data);
								int distance = Math.Min(1048575, (int)Math.Round(CurrentRoute.Tracks[0].Elements[i].StartingTrackPosition + transponder.TrackPositionDelta));
								unchecked
								{
									int value = (int)((uint)speed | ((uint)distance << 12));
									transponders.Add(new TransponderEvent(CurrentRoute, 0.0, TransponderTypes.AtsPTemporarySpeedLimit, value, 0, false));
								}
							}
						}
					}
				}
				int n = CurrentRoute.Tracks[0].Elements[0].Events.Length;
				Array.Resize(ref CurrentRoute.Tracks[0].Elements[0].Events, n + transponders.Count);
				for (int i = 0; i < transponders.Count; i++)
				{
					CurrentRoute.Tracks[0].Elements[0].Events[n + i] = transponders[i];
				}
			}
			// cant
			if (!PreviewOnly)
			{
				ComputeCantTangents();
				int subdivisions = (int)Math.Floor(Data.BlockInterval / 5.0);
				if (subdivisions >= 2)
				{
					Plugin.CurrentRoute.Tracks[0].SmoothTurns(subdivisions, Plugin.CurrentHost);
					ComputeCantTangents();
				}
			}
		}

		private void ComputeCantTangents()
		{
			for (int ii = 0; ii < CurrentRoute.Tracks.Count; ii++)
			{
				int i = CurrentRoute.Tracks.ElementAt(ii).Key;
				CurrentRoute.Tracks[i].ComputeCantTangents();
			}
		}
	}
}
